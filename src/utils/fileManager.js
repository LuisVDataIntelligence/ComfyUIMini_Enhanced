const fs = require('fs');
const path = require('path');
const logger = require('./logger');
const config = require('config');

function checkForWorkflowsFolder() {
    const workflowsFilepath = path.join(__dirname, '..', '..', 'workflows');

    if (!fs.existsSync(workflowsFilepath)) {
        fs.mkdirSync(workflowsFilepath);

        logger.info(`Workflow folder not found, creating...`);
        return;
    }

    try {
        const filesList = fs.readdirSync(workflowsFilepath);
        const listJsonFiles = filesList.filter((file) => path.extname(file).toLowerCase() === '.json');

        loadServerWorkflowMetadata(workflowsFilepath, listJsonFiles);
    } catch (err) {
        console.error('Error reading workflows folder: ', err);
    }
}

/**
 * Loads short metadata for all valid workflows in the workflows folder.
 *
 * @param {string} workflowsFolder The folder where the workflows are stored.
 * @param {string[]} jsonFileList List of JSON files in the workflows folder.
 */
function loadServerWorkflowMetadata(workflowsFolder, jsonFileList) {
    const serverWorkflowMetadata = {};

    for (const jsonFilename of jsonFileList) {
        const jsonFileContents = fs.readFileSync(path.join(workflowsFolder, jsonFilename), 'utf8');
        const parsedJsonContents = JSON.parse(jsonFileContents);

        const jsonMetadata = parsedJsonContents['_comfyuimini_meta'];

        if (!jsonMetadata) {
            if (config.auto_convert_comfyui_workflows === false) {
                continue;
            }

            const autoGeneratedMetadata = autoGenerateMetadata(parsedJsonContents, jsonFilename, workflowsFolder);

            if (autoGeneratedMetadata === null) {
                logger.warn(`'${jsonFilename}' was not recognized as a valid ComfyUI workflow`);
                continue;
            }

            logger.info(
                `Created auto-generated ComfyUIMini metadata for '${jsonFilename}', to disable this feature you can disable it in config.`
            );

            serverWorkflowMetadata[`[CONVERTED] ${jsonFilename}`] = {
                title: jsonFilename,
                filename: `[CONVERTED] ${jsonFilename}`,
                description: 'Auto generated.',
            };

            continue;
        }

        serverWorkflowMetadata[jsonFilename] = {
            title: jsonMetadata.title,
            filename: jsonFilename,
            description: jsonMetadata.description,
        };
    }

    logger.info(`Found ${Object.keys(serverWorkflowMetadata).length} valid workflows in the workflow folder.`);

    config.serverWorkflowMetadata = serverWorkflowMetadata;
}

/**
 * Checks if a JSON workflow object is a valid ComfyUI workflow.
 *
 * @param {object} workflowJson The workflow JSON object.
 * @returns {boolean} True if workflow is a valid ComfyUI workflow, otherwise false.
 */
function checkIfJsonIsValidWorkflow(workflowJson) {
    for (const key of Object.keys(workflowJson)) {
        if (workflowJson[key].inputs && typeof workflowJson[key].inputs === 'object') {
            return true;
        }
    }

    return false;
}

/**
 * Attempts to auto-generate metadata for a ComfyUI server workflow and saves it to the workflows folder.
 *
 * @param {object} workflowJson The workflow JSON object.
 * @param {string} jsonFilename The filename of the workflow in the workflows folder.
 * @param {string} workflowsFolder The path to the workflows folder.
 * @returns {object|null} Returns an object containing the generated metadata, if JSON is not a valid workflow, returns null.
 */
function autoGenerateMetadata(workflowJson, jsonFilename, workflowsFolder) {
    if (checkIfJsonIsValidWorkflow(workflowJson) === false) {
        return null;
    }

    const generatedMetadata = {
        title: jsonFilename,
        description: 'Auto generated.',
        format_version: '1',
        input_options: [],
    };

    for (const [nodeId, nodeJson] of Object.entries(workflowJson)) {
        if (nodeId.charAt(0) == '_') {
            continue;
        }

        const nodeTitle = nodeJson['_meta'].title;

        for (const [inputName, inputValue] of Object.entries(nodeJson.inputs)) {
            if (Array.isArray(inputValue)) {
                // Inputs that come from other nodes come as an array
                continue;
            }

            generatedMetadata.input_options.push({
                node_id: nodeId,
                input_name_in_node: inputName,
                title: `[${nodeTitle}] ${inputName}`,
                default: inputValue,
                ...predictInputTypeAndOptions(inputName),
            });
        }
    }

    const fullWorkflowJson = {
        ...workflowJson,
        _comfyuimini_meta: generatedMetadata,
    };

    fs.writeFileSync(
        path.join(workflowsFolder, `[CONVERTED] ${jsonFilename}`),
        JSON.stringify(fullWorkflowJson, null, 2),
        'utf8'
    );
    fs.renameSync(path.join(workflowsFolder, jsonFilename), path.join(workflowsFolder, `${jsonFilename}.bak`));

    return generatedMetadata;
}

/**
 * Predict the input type and the additional input options for a workflow input.
 *
 * @param {string} inputName The name/id of the input.
 * @returns {object} An object containing the predicted input type and any additional input options.
 */
function predictInputTypeAndOptions(inputName) {
    const predictions = {
        seed: {
            type: 'integer',
            show_randomise_toggle: true,
        },
        steps: {
            type: 'integer',
        },
        cfg: {
            type: 'float',
        },
        sampler_name: {
            type: 'select',
            select_list: 'sampler',
        },
        scheduler: {
            type: 'select',
            select_list: 'scheduler',
        },
        denoise: {
            type: 'float',
        },
        ckpt_name: {
            type: 'select',
            select_list: 'checkpoint',
        },
        width: {
            type: 'integer',
            min: 1,
        },
        height: {
            type: 'integer',
            min: 1,
        },
        batch_size: {
            type: 'integer',
        },
        text: {
            type: 'text',
        },
        filename_prefix: {
            type: 'text',
        },
        vae_name: {
            type: 'select',
            select_list: 'vae',
        },
    };

    return predictions[inputName] || { type: 'text' };
}

function recursiveFolderRead(folderPath, basePath, accepted_exts, fileList = []) {
    const files = fs.readdirSync(folderPath);

    files.forEach((file) => {
        const filePath = path.join(folderPath, file);

        const stats = fs.statSync(filePath);

        if (stats.isDirectory()) {
            recursiveFolderRead(filePath, basePath, accepted_exts, fileList);
        } else if (stats.isFile()) {
            const fileExt = path.extname(file).toLowerCase();

            if (accepted_exts.includes(fileExt)) {
                const relativePath = path.relative(basePath, filePath);
                fileList.push(relativePath);
            }
        }
    });

    return fileList;
}

function loadModelTypes() {
    const modelDirsConfigPath = path.join(__dirname, '..', '..', 'model_dirs.json');

    if (!fs.existsSync(modelDirsConfigPath)) {
        fs.copyFileSync(path.join(__dirname, '..', '..', 'model_dirs.example.json'), modelDirsConfigPath);
    }

    // readFileSync is preferable here as require() wouldn't reflect changes during runtime (user changing model path)
    const modelDirsConfigJson = JSON.parse(fs.readFileSync(modelDirsConfigPath));

    if (!modelDirsConfigJson.checkpoint || modelDirsConfigJson.checkpoint.folder_path == 'path/to/checkpoints/folder') {
        logger.warn('model_dirs.json not configured, you will be unable to select models until it is set.');
        return {};
    }

    const models = {};

    for (const [modelTypeName, modelTypeInfo] of Object.entries(modelDirsConfigJson)) {
        try {
            const fileList = recursiveFolderRead(
                modelTypeInfo.folder_path,
                modelTypeInfo.folder_path,
                modelTypeInfo.filetypes
            );

            models[modelTypeName] = fileList;
        } catch (err) {
            if (err.code == 'ENOENT') {
                logger.warn(`Invalid directory for ${modelTypeName} in model_dirs.json`);
                continue;
            }

            console.err('Error when reading model_dirs.json: ', err);
        }
    }

    logger.info(`Loaded ${Object.keys(models).length} model types.`);

    return models;
}

function loadSelectOptions() {
    const selectsFromFile = require('../../selects.json');

    const modelSelects = loadModelTypes();

    // Merge selectsFromFile into modelSelects, then set config var to that
    Object.assign(modelSelects, selectsFromFile);

    config.selectOptions = modelSelects;
}

// Workflows
function getWorkflowFromFile(fileName) {
    try {
        const fileContents = fs.readFileSync(path.join(__dirname, '..', '..', 'workflows', fileName));
        const workflowJson = JSON.parse(fileContents);

        return workflowJson;
    } catch (error) {
        if (error.code === 'ENOENT') {
            return 'invalid';
        }

        console.error('Error when reading workflow from file:', error);
        return 'error';
    }
}

function writeToWorkflowFile(fileName, workflowJson) {
    try {
        fs.writeFileSync(
            path.join(__dirname, '..', '..', 'workflows', fileName),
            JSON.stringify(workflowJson, null, 2),
            'utf8'
        );
        return true;
    } catch (error) {
        console.error('Error when saving edited workflow to file:', error);
        return false;
    }
}

module.exports = {
    checkForWorkflowsFolder,
    loadSelectOptions,
    loadModelTypes,
    getWorkflowFromFile,
    writeToWorkflowFile,
    recursiveFolderRead,
};
